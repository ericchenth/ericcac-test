#!/usr/bin/env python
# encoding: utf-8
"""
bgp.py

Created by Thomas Mangin on 2009-08-30.
Copyright (c) 2009 Exa Networks. All rights reserved.
"""

import sys
import os
import time
import signal
import socket
import errno

from bgp.network.peer import Peer

from bgp.log import Logger
logger = Logger()

class Supervisor (object):
	pid_file = os.environ.get('PID','')

	# import os
	# [hex(ord(c)) for c in os.popen('clear').read()]
	clear = ''.join([chr(int(c,16)) for c in ['0x1b', '0x5b', '0x48', '0x1b', '0x5b', '0x32', '0x4a']])

	def __init__ (self,configuration):
		self.configuration = configuration
		self._peers = {}
		self._shutdown = False
		self._reload = False
		self._restart = False
		self.reload()

		signal.signal(signal.SIGTERM, self.sigterm)
		signal.signal(signal.SIGHUP, self.sighup)
		signal.signal(signal.SIGALRM, self.sigalrm)

	def _is_socket (self,fd):
		try:
			s = socket.fromfd(fd, socket.AF_INET, socket.SOCK_RAW)
		except ValueError,e:
			# The file descriptor is closed
			return False
		try:
			what = s.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE)
		except socket.error, e:
			# It is look like one but it is not a socket ...
			if e.args[0] == errno.ENOTSOCK:
				return False
		return True

	def fork (self):
		if os.environ.get('DAEMON','0') == '0':
			return
		
		def fork_exit ():
			try:
				pid = os.fork()
				if pid > 0:
					os._exit(0)
			except OSError, e:
				logger.critial('can not fork, errno %d : %s' % (e.errno,e.strerror),'supervisor')

		# do not detach if we are already supervised or run by init like process
		if self._is_socket(sys.__stdin__.fileno()) or os.getppid() != 1:
			fork_exit()
			os.setsid()
			fork_exit()
			if not os.environ.get('SYSLOG',''):
				# XXX: Force SYSLOG, we need to be able to access the local syslog deamon
				# os.environ['SYSLOG']='??'
				pass


	def savepid (self):
		if not self.pid_file:
			return

		ownid = os.getpid()

		flags = os.O_CREAT | os.O_EXCL | os.O_WRONLY
		mode = ((os.R_OK | os.W_OK) << 6) | (os.R_OK << 3) | os.R_OK

		try:
			fd = os.open(self.pid_file,flags,mode)
		except OSError, e:
			logger.supervisor("PIDfile already exists, not updated %s" % self.pid_file)
			return

		try:
			f = os.fdopen(fd,'w')
			line = "%d\n" % ownid
			f.write(line)
			f.close()
		except IOError, e:
			logger.supervisor("Can not create PIDfile %s" % self.pid_file)
			return
		logger.supervisor("created PIDfile %s with value %d" % (self.pid_file,ownid))


	def removepid (self):
		if not self.pid_file:
			return
		try:
			os.remove(self.pid_file)
		except OSError, e:
			if e.errno == errno.ENOENT:
				pass
			else:
				logger.supervisor("Can not remove PIDfile %s" % self.pid_file)
				return
		logger.supervisor("removed PIDfile %s" % self.pid_file)


	def sigterm (self,signum, frame):
		logger.supervisor("SIG TERM received")
		self._shutdown = True

	def sighup (self,signum, frame):
		logger.supervisor("SIG HUP received")
		self._reload = True

	def sigalrm (self,signum, frame):
		logger.supervisor("SIG ALRM received")
		self._restart = True

	def run (self):
		self.fork()
		self.savepid()
		while self._peers:
			try:
				if self._shutdown:
					self._shutdown = False
					self.shutdown()
				elif self._reload:
					self._reload = False
					self.reload()
				elif self._restart:
					self._restart = False
					self.restart()

				# Handle all connection
				for ip in self._peers.keys():
					peer = self._peers[ip]
					peer.run()

				# RFC state that we MUST not more than one KEEPALIVE / sec
				time.sleep(1.0)
			except KeyboardInterrupt:
				logger.supervisor("^C received")
				self._shutdown = True
		self.removepid()

	def shutdown (self):
		"""terminate all the current BGP connections"""
		logger.info("performing shutdown","supervisor")
		for ip in self._peers.keys():
			self._peers[ip].stop()

	def reload (self):
		"""reload the configuration and send to the peer the route which changed"""
		logger.info("performing reload","configuration")
		
		reloaded = self.configuration.reload()
		if not reloaded:
			logger.info("problem with the configuration file, no change done","configuration")
			logger.info(configuration.error,"configuration")
			return

		for ip in self._peers.keys():
			if ip not in self.configuration.neighbor.keys():
				logger.supervisor("Removing Peer %s" % str(ip))
				self._peers[ip].stop()

		for ip in self.configuration.neighbor.keys():
			neighbor = self.configuration.neighbor[ip]
			# new peer
			if ip not in self._peers.keys():
				logger.supervisor("New Peer %s" % str(ip))
				peer = Peer(neighbor,self)
				self._peers[ip] = peer
			else:
				# check if the neighbor definition are the same (BUT NOT THE ROUTES)
				if self._peers[ip].neighbor != neighbor:
					logger.supervisor("Peer definition change, restarting %s" % str(ip))
					self._peers[ip].restart(neighbor)
				# set the new neighbor with the new routes
				else:
					logger.supervisor("updating routes for %s" % str(ip))
					self._peers[ip].reload(neighbor.routes)
		logger.info("loaded new configuration successfully",'configuration')

	def restart (self):
		"""kill the BGP session and restart it"""
		logger.info("performing restart","supervisor")
		self.configuration.reload()

		for ip in self._peers.keys():
			if ip not in self.configuration.neighbor.keys():
				logger.supervisor("Removing Peer %s" % str(ip))
				self._peers[ip].stop()
			else:
				self._peers[ip].restart()

	def unschedule (self,peer):
		ip = peer.neighbor.peer_address.ip
		if ip in self._peers:
			del self._peers[ip]

if __name__ == '__main__':
	main = int(sys.version[0])
	secondary = int(sys.version[2])

	if main != 2 or secondary < 4:
		sys.exit('This program can not work (is not tested) with your python version (< 2.4 or >= 3.0)')

	if main == 2 and secondary == 4:
		sys.stdout.write('\n')
		sys.stdout.write('************ WARNING *** WARNING *** WARNING *** WARNING *********\n')
		sys.stdout.write('* This program SHOULD work with your python version (2.4).       *\n')
		sys.stdout.write('* No tests have been performed. Consider python 2.4 unsupported  *\n')
		sys.stdout.write('* Please consider upgrading to the latest 2.x stable realease.   *\n')
		sys.stdout.write('************ WARNING *** WARNING *** WARNING *** WARNING *********\n')
		sys.stdout.write('\n')

	if len(sys.argv) < 2:
		sys.stdout.write('\n')
		sys.stdout.write('*******************************************************************************\n')
		sys.stdout.write('set the following environment values to gather information and report bugs\n')
		sys.stdout.write('\n')
		sys.stdout.write('DEBUG_CONFIGURATION : verbose configuration parsing\n')
		sys.stdout.write('DEBUG_SUPERVISOR : signal received, configuration reload (default: yes))\n')
		sys.stdout.write('DEBUG_WIRE : the packet sent and received\n')
		sys.stdout.write('DEBUG_RIB : change in route announcement in config reload\n')
		sys.stdout.write('DEBUG_MESSAGE : changes in route announcement in config reload (default: yes)\n')
		sys.stdout.write('DEBUG_TIMERS : tracking keepalives\n')
		sys.stdout.write('\n')
		sys.stdout.write('For example :\n')
		sys.stdout.write('> env DEBUG_SUPERVISOR=0 DEBUG_WIRE=1 ./bin/bgpd ./etc/bgp/configuration.txt\n')
		sys.stdout.write('*******************************************************************************\n')
		sys.stdout.write('\n')
		sys.exit('usage:\n bgpd <configuration file>\n')
	conf = sys.argv[1]

	pid = os.getpid()
	gid = os.getgid()

	if not pid or not gid:
		sys.stdout.write('\n')
		sys.stdout.write('*'*80+'\n')
		sys.stdout.write('RUNNING THIS PROGRAM AS ROOT IS INSECURE\n')
		sys.stdout.write('*'*80+'\n')
		sys.stdout.write('\n')

	from bgp.configuration import Configuration

	configuration = Configuration(conf)
	if not configuration.reload():
		sys.exit('%s' % configuration.error)
	supervisor = Supervisor(configuration)
	supervisor.run()
	sys.exit(0)
